import { type Route } from 'next';

import type { StandardSchemaV1 } from '@standard-schema/spec';

import { convertObjectToURLSearchParams } from './convert-object-to-url-search-params';
import type { ExcludeAny } from './types';

type PathBlueprint = `/${string}`;

type Suffix = `?${string}`;

/**
 * When `experimental.typeRoutes` is disabled,
 * `Route` is `string & {}`, therefore `string extends Route` is a truthy condition.
 * If this is the case, we simply use the `Path` value to infer the literal string.
 *
 * If `experimental.typeRoutes` is enabled,
 * `Route` will be a union of string literals, therefore `string extends Route` is a falsy condition.
 * If this is the case, we use `Route<Path>` so that we have auto-complete on the available routes
 * generated by NextJS and validation check against dynamic routes (that are checked by passing the string generic).
 */
type SafePath<Path extends string> = string extends Route ? Path : Route<Path>;

type ExtractPathParams<T extends string> =
  T extends `${infer Rest}[[...${infer Param}]]` ?
    Param | ExtractPathParams<Rest>
  : T extends `${infer Rest}[...${infer Param}]` ?
    Param | ExtractPathParams<Rest>
  : T extends `${string}[${infer Param}]${infer Rest}` ?
    Param | ExtractPathParams<Rest>
  : never;

export type RouteBuilder<
  Path extends string,
  Params extends StandardSchemaV1,
  Search extends StandardSchemaV1,
> =
  [Params, Search] extends [never, never] ?
    { (): Path; getSchemas: () => { params: never; search: never } }
  : [Params, Search] extends [StandardSchemaV1, never] ?
    {
      (options: StandardSchemaV1.InferInput<Params>): Path;
      getSchemas: () => { params: Params; search: never };
    }
  : [Params, Search] extends [never, StandardSchemaV1] ?
    undefined extends StandardSchemaV1.InferInput<Search> ?
      {
        (options?: {
          search?: StandardSchemaV1.InferInput<Search>;
        }): Path | `${Path}${Suffix}`;
        getSchemas: () => { params: never; search: Search };
      }
    : {
        (options: {
          search: StandardSchemaV1.InferInput<Search>;
        }): `${Path}${Suffix}`;
        getSchemas: () => { params: never; search: Search };
      }
  : [Params, Search] extends [StandardSchemaV1, StandardSchemaV1] ?
    undefined extends StandardSchemaV1.InferInput<Search> ?
      {
        (
          options: StandardSchemaV1.InferInput<Params> & {
            search?: StandardSchemaV1.InferInput<Search>;
          },
        ): Path | `${Path}${Suffix}`;
        getSchemas: () => { params: Params; search: Search };
      }
    : {
        (
          options: StandardSchemaV1.InferInput<Params> & {
            search: StandardSchemaV1.InferInput<Search>;
          },
        ): `${Path}${Suffix}`;
        getSchemas: () => { params: Params; search: Search };
      }
  : never;

type EnsurePathWithNoParams<Path extends string> =
  ExtractPathParams<Path> extends never ? SafePath<Path>
  : `[ERROR]: Missing validation for path params`;

/**
 * For Standard Schema, we'll simplify this since we don't have the same object introspection
 */
type StrictParams<
  Schema extends StandardSchemaV1,
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _Keys extends string,
> = Schema;

type RouteBuilderResult<
  Path extends string,
  PathParams extends string,
  Params extends StandardSchemaV1,
  Search extends StandardSchemaV1,
> =
  [PathParams, Search] extends [string, never] ?
    RouteBuilder<Path, Params, never>
  : [PathParams, Search] extends [never, StandardSchemaV1] ?
    RouteBuilder<Path, never, Search>
  : [PathParams, Search] extends [string, StandardSchemaV1] ?
    RouteBuilder<Path, Params, Search>
  : never;

const PATH_PARAM_REGEX = /\[{1,2}([^[\]]+)]{1,2}/g;

/**
 * Remove param notation from string to only get the param name when it is a catch-all segment
 *
 * @example
 * ```ts
 * '/shop/[[...slug]]'.replace(PATH_PARAM_REGEX, (match, param) => {
 *   //                                                    ^? '[[...slug]]'
 *   const [sanitizedParam] = REMOVE_PARAM_NOTATION_REGEX.exec(param)
 *   //          ^? 'slug'
 * })
 * ```
 */
const REMOVE_PARAM_NOTATION_REGEX = /[^[.].+[^\]]/;

// @ts-expect-error overload signature does match the implementation,
// the compiler complains about EnsurePathWithNoParams, but it is fine
export function makeRouteBuilder<Path extends PathBlueprint>(
  path: EnsurePathWithNoParams<Path>,
): RouteBuilder<Path, never, never>;

export function makeRouteBuilder<
  Path extends PathBlueprint,
  Params extends StandardSchemaV1,
  Search extends StandardSchemaV1 = never,
>(
  path: SafePath<Path>,
  schemas: ExtractPathParams<Path> extends never ? { search: Search }
  : {
      params: StrictParams<Params, ExtractPathParams<Path>>;
      search?: Search;
    },
): RouteBuilderResult<
  Path,
  ExtractPathParams<Path>,
  ExcludeAny<Params>,
  ExcludeAny<Search>
>;

export function makeRouteBuilder(
  path: PathBlueprint,
  schemas?: { params?: StandardSchemaV1; search?: StandardSchemaV1 },
): any {
  if (!path.startsWith('/')) {
    path = `/${path}`;
  }

  const hasParamsInPath = PATH_PARAM_REGEX.test(path);
  const isMissingParamsValidation = hasParamsInPath && !schemas?.params;

  if (isMissingParamsValidation) {
    throw new Error(`Validation missing for path params: "${path}"`);
  }

  const routeBuilder: RouteBuilder<string, any, any> = (options) => {
    const { search = {}, ...params } = options ?? {};

    const basePath = path.replace(PATH_PARAM_REGEX, (match, param: string) => {
      const sanitizedParam = REMOVE_PARAM_NOTATION_REGEX.exec(param)?.[0];

      const value = params[sanitizedParam ?? param];

      if (Array.isArray(value)) {
        return value.join('/');
      }

      return value ?? match;
    });

    const urlSearchParams = convertObjectToURLSearchParams(search);

    if (!urlSearchParams.entries().next().done) {
      return [basePath, urlSearchParams.toString()].join('?');
    }

    return basePath;
  };

  routeBuilder.getSchemas = () => ({
    params: schemas?.params,
    search: schemas?.search,
  });

  return routeBuilder;
}

export type makeRouteBuilder = typeof makeRouteBuilder;
